{-# LANGUAGE CPP, DeriveDataTypeable, RecordWildCards, ScopedTypeVariables #-}
-----------------------------------------------------------------------------
{- |
 Module      :  Data.Acid.Remote.TLS
 Copyright   :  PublicDomain

 Maintainer  :  lemmih@gmail.com, jeremy@n-heptane.com
 Portability :  non-portable (uses GHC extensions)

 Network backend secured using TLS/SSL

-}
module Data.Acid.RemoteSSL
    (
    -- * Server/Client
      acidServerTLS
    , openRemoteStateTLS
    -- * Authentication
    , skipAuthenticationCheck
    , skipAuthenticationPerform
    , sharedSecretCheck
    , sharedSecretPerform

    ) where

import Control.Concurrent           ( forkIO, threadDelay )
import Control.Concurrent.STM       ( atomically )
import Control.Concurrent.STM.TMVar ( TMVar, newEmptyTMVar, readTMVar, tryTakeTMVar, putTMVar)
import Control.Exception            ( Handler(..), IOException, SomeException, catch, catches, handle
                                    , finally, throwIO )
import Control.Monad                ( forever, when )
import Data.Acid                    ( AcidState, IsAcidic )
import Data.Acid.Remote             ( CommChannel(..), process, processRemoteState, skipAuthenticationCheck
                                    , skipAuthenticationPerform, sharedSecretCheck, sharedSecretPerform )
import qualified Data.ByteString    as Strict
import Data.SafeCopy               ( SafeCopy )
import GHC.IO.Exception            ( IOErrorType(..) )
import           OpenSSL           ( withOpenSSL )
import           OpenSSL.Session   ( SomeSSLException, SSL, SSLContext )
import qualified OpenSSL.Session   as SSL
import Network                     ( HostName, PortID(..), PortNumber, Socket, listenOn, sClose )
import Network.Socket              as Socket ( Family(..), SockAddr(..), SocketType(..), accept, socket, connect )
import Network.BSD                 ( getHostByName, getProtocolNumber, hostAddress )
import System.IO.Error             ( ioeGetErrorType, isFullError, isDoesNotExistError )

initSSLContext :: FilePath  -- ^ path to ssl certificate
               -> FilePath  -- ^ path to ssl private key
               -> IO SSLContext
initSSLContext cert key =
    do ctx <- SSL.context
       SSL.contextSetPrivateKeyFile  ctx key
       SSL.contextSetCertificateFile ctx cert
       SSL.contextSetDefaultCiphers  ctx

       certOk <- SSL.contextCheckPrivateKey ctx
       when (not certOk) $ error $ "OpenTLS certificate and key do not match."

       return ctx

-- | accept a TLS connection
acceptTLS :: SSLContext -> Socket -> IO (Socket, SSL, SockAddr)
acceptTLS ctx sck' =
    do -- do normal accept
      (sck, sockAddr) <- accept sck'
      --  then TLS accept
      handle (\ (e :: SomeException) -> sClose sck >> throwIO e) $ do
          ssl <- SSL.connection ctx sck
          SSL.accept ssl
          return (sck, ssl, sockAddr)

{- | Accept connections on @port@ and serve requests using the given 'AcidState'.
     This call doesn't return.

     The connection is secured using TLS/SSL.

     see also: 'openRemoteStateTLS' and 'sharedSecretCheck'.
 -}
acidServerTLS :: SafeCopy st =>
                 FilePath                 -- ^ path to ssl certificate
              -> FilePath                 -- ^ path to ssl private key
              -> (CommChannel -> IO Bool) -- ^ authorization function
              -> PortNumber               -- ^ port to list on
              -> AcidState st             -- ^ 'AcidState' to serve
              -> IO ()
acidServerTLS sslCert sslKey checkAuth port acidState
  = do withOpenSSL $ return ()
       tlsSocket <- listenOn (PortNumber $ fromIntegral port)
       ctx       <- initSSLContext sslCert sslKey
       let worker :: (Socket, SSL, SockAddr) -> IO ()
           worker (socket, ssl, _sockAddr) =
               do -- TODO: log this connection, sockAddr
                  let socketCommChannel :: CommChannel
                      socketCommChannel = CommChannel
                        { ccPut     = SSL.write ssl
                        , ccGetSome = SSL.read ssl
                        , ccClose   = shutdownClose socket ssl
                        }
                  forkIO $ (do authorized <- checkAuth socketCommChannel
                               when authorized $
                                    ignoreSome $ (process socketCommChannel acidState)
                               ccClose socketCommChannel) `catch` (\(e::SomeException) -> do
                                                                     shutdownClose socket ssl
                                                                     throwIO e)
                  return ()
           loop :: IO ()
           loop = do ignoreSome $ (forever $ worker =<< acceptTLS ctx tlsSocket)
                     loop
       loop `finally` (sClose tlsSocket `catch` ignoreException)

    where
      -- exception handlers
      ignoreConnectionAbruptlyTerminated :: SSL.ConnectionAbruptlyTerminated -> IO ()
      ignoreConnectionAbruptlyTerminated _ = return ()

      ignoreSSLException :: SSL.SomeSSLException -> IO ()
      ignoreSSLException _ = return ()

      ignoreException :: SomeException -> IO ()
      ignoreException _ = return ()

      shutdownClose :: Socket -> SSL -> IO ()
      shutdownClose socket ssl =
          do SSL.shutdown ssl SSL.Unidirectional `catch` ignoreException
             sClose socket `catch` ignoreException

      ignoreSome op =
               op `catches` [ Handler $ ignoreSSLException
                            , Handler $ ignoreConnectionAbruptlyTerminated
                            , Handler $ \(e :: IOException)    ->
                                  if isFullError e || isDoesNotExistError e || isResourceVanishedError e
                                  then return ()
                                  else throwIO e
                              ]

      isResourceVanishedError :: IOException -> Bool
      isResourceVanishedError = isResourceVanishedType . ioeGetErrorType

      isResourceVanishedType :: IOErrorType -> Bool
      isResourceVanishedType ResourceVanished = True
      isResourceVanishedType _                = False

{- | Connect to a remotely running 'AcidState'.

The connection is secured using SSL/TLS.
 -}
openRemoteStateTLS  :: IsAcidic st =>
                       (CommChannel -> IO ()) -- ^ authentication function, see 'sharedSecretPerform'
                    -> HostName               -- ^ remote host to connect to
                    -> PortNumber             -- ^ remote port to connect to
                    -> IO (AcidState st)
openRemoteStateTLS performAuthorization host port
  = do withOpenSSL $ return ()
       tmSSL <- atomically $ newEmptyTMVar
       let cc = CommChannel { ccGetSome = getSome tmSSL
                            , ccPut     = put tmSSL
                            , ccClose   = close tmSSL
                            }
           r = reconnect tmSSL
       r
       processRemoteState cc
    where
      sslCommChannel ssl =
         CommChannel { ccGetSome = SSL.read ssl
                     , ccPut     = SSL.write ssl
                     , ccClose   = do SSL.shutdown ssl SSL.Unidirectional
                                      --   close ssl
                     }

      -- | reconnect
      reconnect :: TMVar SSL -> IO ()
      reconnect tmSSL
          = (do ssl <- connectToTLS host port
                performAuthorization (sslCommChannel ssl)
                mOldSSL <- atomically $
                              do mSSL <- tryTakeTMVar tmSSL
                                 putTMVar tmSSL ssl
                                 return mSSL
--                whenJust mOldSSL $ forkIO . hClose -- FIXME
                return ()
            )
            `catch`
            ((\e -> threadDelay 1000000 >> reconnect tmSSL) :: IOError -> IO ())
      -- | getSome
      getSome :: TMVar SSL -> Int -> IO Strict.ByteString
      getSome tmSSL count =
          do ssl <- atomically $ readTMVar tmSSL
             (SSL.read ssl count) `catch` ((\_ -> reconnect tmSSL >> getSome tmSSL count) :: IOError -> IO Strict.ByteString)

      put :: TMVar SSL -> Strict.ByteString -> IO ()
      put tmSSL bs =
          do ssl <- atomically $ readTMVar tmSSL
             (SSL.write ssl bs) `catch` ((\_ -> reconnect tmSSL >> put tmSSL bs) :: IOError -> IO ())

      close :: TMVar SSL -> IO ()
      close tmSSL =
          do mSSL <- atomically $ tryTakeTMVar tmSSL
--             whenJust mHandle $ forkIO .hClose
             return ()


-- IPV4 support only, sorry
connectToTLS :: HostName
             -> PortNumber
             -> IO SSL
connectToTLS hostName port
  = do proto <- getProtocolNumber "tcp"
       sock <- socket AF_INET Stream proto
       (do he <- getHostByName hostName
           Socket.connect sock (SockAddrInet port (hostAddress he))
           ctx <- SSL.context
           ssl <- SSL.connection ctx sock
           SSL.connect ssl
           return ssl) `catch` (\e -> do print (e :: SomeSSLException)
                                         sClose sock
                                         throwIO e
                               )
